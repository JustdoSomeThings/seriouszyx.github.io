---
title: 计算机组成原理题目总结
tags: [计算机组成原理]
copyright: true
date: 2019-06-19 20:54:19
categories: 课程总结
---

![](https://i.loli.net/2019/06/19/5d099e461a87529141.png)

<!-- more -->

## 第二章 运算方法和运算器

![](https://i.loli.net/2019/06/19/5d099e461a87529141.png)

C语言支持所有整型数据类型的有符号数和无符号数运算。16位的**无符号整数**a等于65530，十六进制表示为FFFA，32位的无符号整数b等于a，即65530，十六进制表示为OOOOFFFAH。

![](https://i.loli.net/2019/06/19/5d09a2c4870d218211.png)

IEEE754浮点数真值：

- 32位：N =（-1)^S ×（1.M）× 2^(E-127)
- 64位：N =（-1)^S ×（1.M）× 2^(E-1023)


<div class="answer-brief nc-post-content"><div>  考察浮点数的表示。 </div>
<div>  对于一个非0且不是无穷大的浮点数，其阶码实际值为-126~+127，对应移码1~254。 </div>
<div>  尾数的最大值为：0.1111.....111111共23位小数 </div>
<div>  取阶码127，即指数127。 </div>
<div>  那么，根据<span style="color: rgb(51,51,51);">X = (-1)</span>
  <sup>s</sup>
  <span style="color: rgb(51,51,51);">×(1.M)×2</span>
  <sup>&nbsp;E-127</sup>
  <span style="color: rgb(51,51,51);">&nbsp; ，有</span>
</div>
<div>
  <span style="color: rgb(51,51,51);">最大值为 (1.11111.....1)<sub>2</sub>
  </span>
  <span style="color: rgb(51,51,51);">×2<sup>127&nbsp;</sup>=(1+1-2<sup>-23</sup>)</span>
  <span style="color: rgb(51,51,51);">×2</span>
  <sup>127</sup>
  <span style="color: rgb(51,51,51);">= (2-2</span>
  <span style="color: rgb(51,51,51);">
    <sup>-23</sup>)</span>
  <span style="color: rgb(51,51,51);">×2</span>
  <sup>127</sup>
  <span style="color: rgb(51,51,51);">= DCUP</span>
</div>
<div>
  <br>
</div></div>

至于本题中的最大数，它的编码形式是这样的 

0 11111110 11111111111111111111111

![](https://i.loli.net/2019/06/19/5d09a55fcbac816823.png)

![](https://i.loli.net/2019/06/19/5d09b86029dac28881.png)

![](https://i.loli.net/2019/06/19/5d09b896428b171084.png)

![](https://i.loli.net/2019/06/19/5d09b9689d55248590.png)

1. 表示一个补码整数，其十进制值是多少？
 
作为补码整数，其对应的原码是

1111  0000  0001   0000  0100  0000   0000  0000

十进制值是 -（2^30+ 2^29 +2^28 + 2^20 + 2^14 ）

2. 表示一个无符号整数，其十进制值是多少？

作为无符号整数，其十进制值是

2^31+ 2^27+ 2^26 +2^25 + 2^24 + 2^23+ 2^22 +2^21 + 2^19 +2^18 + 2^17 +2^16 + 2^15 + 2^14

3.  作为IEEE754标准的单精度浮点数

二进制数：1 00011111 11011111100000000000000

阶码E是0001 1111

指数e＝阶码E－127＝0001 1111－0111 1111	＝-1100000B＝-96D

尾数M=110 1111  1100  0000   0000  0000

则1.M	=1. 110 1111 1100 0000 0000 000	=1.110 1111 11

单精度浮点数值为:

X ＝(-1)^s × 1.M×2^e

＝-(1.110 1111 11)×2^(-96)

＝ -(0.1110 1111 11)×2^(-95)
    
＝ -(14×16-1＋15×16-2＋12×16-3)×2^(-95)
    
＝ -0.3115×2^(-95)
    
### 定点加法、减法

![](https://i.loli.net/2019/06/19/5d09be026b30f68619.png)

![](https://i.loli.net/2019/06/19/5d09c0fb273f662491.png)

![](https://i.loli.net/2019/06/19/5d09c34bcacd778168.png)

8位补码的范围：
-128 ~ 127

![](https://i.loli.net/2019/06/19/5d09c3be1302858971.png)

C语言的数据在内存中为补码形式，故x、y的机器数写为十六进制为0000007FH、FFF7H。

执行z=x+y时，由于x为int型，y为short型，故需将y的类型强制转换为int，在机器中通过符号位扩展实现，由于y的符号位为1，故在y的前面添加16个1，即可将y强制转换为int型，其十六进制形式为FFFFFFF7H；然后执行加法，即0000007FH+FFFFFFF7H=00000076H最高位的进位1自然丢弃)。故选D。

### 定点乘法、除法

![](https://i.loli.net/2019/06/19/5d09c664423de48771.png)

乘以2为左移一位：2x=1110 1000

除以2为右移一位：y/2=1101 1000

### 浮点运算

![](https://i.loli.net/2019/06/19/5d09c84d35a4823399.png)

原码表示时，首位为1是规格化浮点数。


### 总结

![](https://i.loli.net/2019/06/19/5d09cb7e3641380601.png)

![](https://i.loli.net/2019/06/19/5d09cc7f73f3c10985.png)

最小的数肯定是负数，首先第一位就是1 ，又因为补码要取反，所以最小的数应该是 1,0000011.除开符号位取反加1后变成 1,1111101。这个数的十进制是-125。

![](https://i.loli.net/2019/06/19/5d09d10451a0174633.png)


对阶是较小的阶码对齐至较大的阶码，Ⅰ 正确。

右规和尾数舍入过程，阶码加 1 而可能上溢，Ⅱ 正确，同理   Ⅲ也   正确。

尾数溢出时可能仅产生误差，结果不一定溢出， Ⅳ 正确。


## 多层次的存储器

### SRAM 和 DRAM

设某存储系统的存取周期为500ns，每个存取周期可访问16位，则该存储器的带宽是多少？

```
存储带宽= 每周期的信息量 / 周期时长
                  = 16位/(500 ╳10^-9)秒
                  = 3.2 ╳ 10^7 位/秒
                  = 32 ╳ 10^6 位/秒  =  32M位/秒

```

![](https://i.loli.net/2019/06/19/5d09f332c216890746.png)

CD只读存储器，意即只能读不能写，区别于CD RAM，可读写CD存储器。

![](https://i.loli.net/2019/06/19/5d09f39f73fd542268.png)

设CPU有16根地址线,8根数据线,用/MREQ作访存控制,现有下列芯片:1K×4RAM;  4K×8RAM;  8K×8RAM;  2K×8ROM； 4K×8ROM； 8K×8ROM及74LS138等电路,要求主存地址空间满足:最小8K为系统程序区,与其相邻的16K地址为用户程序区，指出芯片种类及片数,并写出每个芯片的地址范围。(注意,请写十六进制数据）

![](https://i.loli.net/2019/06/19/5d09fee4542fb23956.png)

![](https://i.loli.net/2019/06/19/5d09ff866fe5685787.png)

![](https://i.loli.net/2019/06/19/5d09ffce5d10639871.png)

![](https://i.loli.net/2019/06/19/5d0a1ce7b016c34602.png)

该机主存由4 K×8位ROM和60 K×8位RAM组成；又现有ROM芯片为2 K×8位，故ROM需进行字扩展，用2片2 K×8位ROM串联组成4 K×8位ROM；RAM芯片为4 K×4位，故RAM需进行位字扩展，用2片4 K×4位RAM并联构成4 K×8位RAM，再用15片4 K×8位RAM串联组成60 K×8位RAM，即共需2×15=30片4 K×4位的RAM芯片。


![](https://i.loli.net/2019/06/19/5d0a1d809012744819.png)


注意，既然是8K X 8位的存储器，那么单位就是8位也就是一个字节。寻址的时候也是以字节为单位。

而一个芯片只能提供1K X8 的地址。也就是一共需要8个芯片。

每个芯片的地址范围都是 0100 0000 0000

第1个芯片地址范围：0000 0000 0000 0000 ~ 0000 0100 0000 0000  即0000H ~ 0800H

第2个芯片地址范围：0000 0100 0000 0000 ~ 0000 1000 0000 0000  即0800H ~ 1000H

……

第8个芯片地址范围：0001 1100 0000 0000 ~ 0010 0000 0000 0000 即1C00H ~ 2000H  

存储器8K 正好也是2^13  0000H ~2000H

![](https://i.loli.net/2019/06/19/5d0a1ec6ae49e15652.png)

![](https://i.loli.net/2019/06/19/5d0a1f912279945822.png)

容量为 4M * 8，4M = 2^(2+10+10) B，则需要 22 条地址线、8 条数据线。 
DRAM 芯片的地址线，在芯片中，是分时复用的，仅需一半的引脚数，即够用。

22 / 2 + 8 = 19 条

![](https://i.loli.net/2019/06/19/5d0a215f2f74414181.png)

4000H-5FFFH = 8K

((64 - 8)k * 8) / (8k * 4) = 14。


### 并行存储器

![](https://i.loli.net/2019/06/19/5d0a251aab06352530.png)


![](https://i.loli.net/2019/06/19/5d0a25906886569306.png)

### Cache

![](https://i.loli.net/2019/06/19/5d0a28fcc7aa552700.png)






<hr />
