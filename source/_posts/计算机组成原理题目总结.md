---
title: 计算机组成原理题目总结
tags: [计算机组成原理]
copyright: true
date: 2019-06-19 20:54:19
categories: 课程总结
---

![](/uploads/jztm.jpg)

<!-- more -->

## 第二章 运算方法和运算器

![](https://i.loli.net/2019/06/19/5d099e461a87529141.png)

C语言支持所有整型数据类型的有符号数和无符号数运算。16位的**无符号整数**a等于65530，十六进制表示为FFFA，32位的无符号整数b等于a，即65530，十六进制表示为OOOOFFFAH。

![](https://i.loli.net/2019/06/19/5d09a2c4870d218211.png)

IEEE754浮点数真值：

- 32位：N =（-1)^S ×（1.M）× 2^(E-127)
- 64位：N =（-1)^S ×（1.M）× 2^(E-1023)


<div class="answer-brief nc-post-content"><div>  考察浮点数的表示。 </div>
<div>  对于一个非0且不是无穷大的浮点数，其阶码实际值为-126~+127，对应移码1~254。 </div>
<div>  尾数的最大值为：0.1111.....111111共23位小数 </div>
<div>  取阶码127，即指数127。 </div>
<div>  那么，根据<span style="color: rgb(51,51,51);">X = (-1)</span>
  <sup>s</sup>
  <span style="color: rgb(51,51,51);">×(1.M)×2</span>
  <sup>&nbsp;E-127</sup>
  <span style="color: rgb(51,51,51);">&nbsp; ，有</span>
</div>
<div>
  <span style="color: rgb(51,51,51);">最大值为 (1.11111.....1)<sub>2</sub>
  </span>
  <span style="color: rgb(51,51,51);">×2<sup>127&nbsp;</sup>=(1+1-2<sup>-23</sup>)</span>
  <span style="color: rgb(51,51,51);">×2</span>
  <sup>127</sup>
  <span style="color: rgb(51,51,51);">= (2-2</span>
  <span style="color: rgb(51,51,51);">
    <sup>-23</sup>)</span>
  <span style="color: rgb(51,51,51);">×2</span>
  <sup>127</sup>
  <span style="color: rgb(51,51,51);">= DCUP</span>
</div>
<div>
  <br>
</div></div>

至于本题中的最大数，它的编码形式是这样的 

0 11111110 11111111111111111111111

![](https://i.loli.net/2019/06/19/5d09a55fcbac816823.png)

![](https://i.loli.net/2019/06/19/5d09b86029dac28881.png)

![](https://i.loli.net/2019/06/19/5d09b896428b171084.png)

![](https://i.loli.net/2019/06/19/5d09b9689d55248590.png)

1. 表示一个补码整数，其十进制值是多少？
 
作为补码整数，其对应的原码是

1111  0000  0001   0000  0100  0000   0000  0000

十进制值是 -（2^30+ 2^29 +2^28 + 2^20 + 2^14 ）

2. 表示一个无符号整数，其十进制值是多少？

作为无符号整数，其十进制值是

2^31+ 2^27+ 2^26 +2^25 + 2^24 + 2^23+ 2^22 +2^21 + 2^19 +2^18 + 2^17 +2^16 + 2^15 + 2^14

3.  作为IEEE754标准的单精度浮点数

二进制数：1 00011111 11011111100000000000000

阶码E是0001 1111

指数e＝阶码E－127＝0001 1111－0111 1111	＝-1100000B＝-96D

尾数M=110 1111  1100  0000   0000  0000

则1.M	=1. 110 1111 1100 0000 0000 000	=1.110 1111 11

单精度浮点数值为:

X ＝(-1)^s × 1.M×2^e

＝-(1.110 1111 11)×2^(-96)

＝ -(0.1110 1111 11)×2^(-95)
    
＝ -(14×16-1＋15×16-2＋12×16-3)×2^(-95)
    
＝ -0.3115×2^(-95)
    
### 定点加法、减法

![](https://i.loli.net/2019/06/19/5d09be026b30f68619.png)

![](https://i.loli.net/2019/06/19/5d09c0fb273f662491.png)

![](https://i.loli.net/2019/06/19/5d09c34bcacd778168.png)

8位补码的范围：
-128 ~ 127

![](https://i.loli.net/2019/06/19/5d09c3be1302858971.png)

C语言的数据在内存中为补码形式，故x、y的机器数写为十六进制为0000007FH、FFF7H。

执行z=x+y时，由于x为int型，y为short型，故需将y的类型强制转换为int，在机器中通过符号位扩展实现，由于y的符号位为1，故在y的前面添加16个1，即可将y强制转换为int型，其十六进制形式为FFFFFFF7H；然后执行加法，即0000007FH+FFFFFFF7H=00000076H最高位的进位1自然丢弃)。故选D。

### 定点乘法、除法

![](https://i.loli.net/2019/06/19/5d09c664423de48771.png)

乘以2为左移一位：2x=1110 1000

除以2为右移一位：y/2=1101 1000

### 浮点运算

![](https://i.loli.net/2019/06/19/5d09c84d35a4823399.png)

原码表示时，首位为1是规格化浮点数。


### 总结

![](https://i.loli.net/2019/06/19/5d09cb7e3641380601.png)

![](https://i.loli.net/2019/06/19/5d09cc7f73f3c10985.png)

最小的数肯定是负数，首先第一位就是1 ，又因为补码要取反，所以最小的数应该是 1,0000011.除开符号位取反加1后变成 1,1111101。这个数的十进制是-125。

![](https://i.loli.net/2019/06/19/5d09d10451a0174633.png)


对阶是较小的阶码对齐至较大的阶码，Ⅰ 正确。

右规和尾数舍入过程，阶码加 1 而可能上溢，Ⅱ 正确，同理   Ⅲ也   正确。

尾数溢出时可能仅产生误差，结果不一定溢出， Ⅳ 正确。


## 多层次的存储器

### SRAM 和 DRAM

设某存储系统的存取周期为500ns，每个存取周期可访问16位，则该存储器的带宽是多少？

```
存储带宽= 每周期的信息量 / 周期时长
                  = 16位/(500 ╳10^-9)秒
                  = 3.2 ╳ 10^7 位/秒
                  = 32 ╳ 10^6 位/秒  =  32M位/秒

```

![](https://i.loli.net/2019/06/19/5d09f332c216890746.png)

CD只读存储器，意即只能读不能写，区别于CD RAM，可读写CD存储器。

![](https://i.loli.net/2019/06/19/5d09f39f73fd542268.png)

设CPU有16根地址线,8根数据线,用/MREQ作访存控制,现有下列芯片:1K×4RAM;  4K×8RAM;  8K×8RAM;  2K×8ROM； 4K×8ROM； 8K×8ROM及74LS138等电路,要求主存地址空间满足:最小8K为系统程序区,与其相邻的16K地址为用户程序区，指出芯片种类及片数,并写出每个芯片的地址范围。(注意,请写十六进制数据）

![](https://i.loli.net/2019/06/19/5d09fee4542fb23956.png)

![](https://i.loli.net/2019/06/19/5d09ff866fe5685787.png)

![](https://i.loli.net/2019/06/19/5d09ffce5d10639871.png)

![](https://i.loli.net/2019/06/19/5d0a1ce7b016c34602.png)

该机主存由4 K×8位ROM和60 K×8位RAM组成；又现有ROM芯片为2 K×8位，故ROM需进行字扩展，用2片2 K×8位ROM串联组成4 K×8位ROM；RAM芯片为4 K×4位，故RAM需进行位字扩展，用2片4 K×4位RAM并联构成4 K×8位RAM，再用15片4 K×8位RAM串联组成60 K×8位RAM，即共需2×15=30片4 K×4位的RAM芯片。


![](https://i.loli.net/2019/06/19/5d0a1d809012744819.png)


注意，既然是8K X 8位的存储器，那么单位就是8位也就是一个字节。寻址的时候也是以字节为单位。

而一个芯片只能提供1K X8 的地址。也就是一共需要8个芯片。

每个芯片的地址范围都是 0100 0000 0000

第1个芯片地址范围：0000 0000 0000 0000 ~ 0000 0100 0000 0000  即0000H ~ 0800H

第2个芯片地址范围：0000 0100 0000 0000 ~ 0000 1000 0000 0000  即0800H ~ 1000H

……

第8个芯片地址范围：0001 1100 0000 0000 ~ 0010 0000 0000 0000 即1C00H ~ 2000H  

存储器8K 正好也是2^13  0000H ~2000H

![](https://i.loli.net/2019/06/19/5d0a1ec6ae49e15652.png)

![](https://i.loli.net/2019/06/19/5d0a1f912279945822.png)

容量为 4M * 8，4M = 2^(2+10+10) B，则需要 22 条地址线、8 条数据线。 
DRAM 芯片的地址线，在芯片中，是分时复用的，仅需一半的引脚数，即够用。

22 / 2 + 8 = 19 条

![](https://i.loli.net/2019/06/19/5d0a215f2f74414181.png)

4000H-5FFFH = 8K

((64 - 8)k * 8) / (8k * 4) = 14。


### 并行存储器

![](https://i.loli.net/2019/06/19/5d0a251aab06352530.png)


![](https://i.loli.net/2019/06/19/5d0a25906886569306.png)

### Cache

![](https://i.loli.net/2019/06/19/5d0a28fcc7aa552700.png)


某系统的存储器为2MB，每字块为8个字，每字32位，若Cache为16KB，采用字节编址方式。

1. 采用直接映射，主存地址格式是什么？  
2. 采用全相联映射，主存地址格式是什么？  
3. 采用16路组相联映射，主存地址格式是什么？

2MB存储器共21位地址：
16位块地址，3位块内字地址，2位字节地址

16KB的Cache共14位地址：
9位行地址，3位行内字地址，2位字节地址

- 采用直接映射，主存地址格式：

7位主存标记 9位行地址 3位块内地址 2位字节地址

- 采用全相联映射，主存地址格式为：

16位主存标记	3位块内地址	2位字节地址

- 采用16路组相联映射，主存地址格式为：

11位主存标记	5位组地址	3位块内地址	2位字节地址

![](https://i.loli.net/2019/06/20/5d0b23ea5059f65471.png)

129 / 32 = 4 ~ 1


![](https://i.loli.net/2019/06/20/5d0b2581e5aab16161.png)

```
0H=00,00B; 2H=00,10B; 4H=01,00B; 6H=01,10B; 8H=10,00B;
1. 0H分配到块0；且不命中。
2. 4H分配到块1；切不命中。
3. 8H分配到块0，覆盖0H内容；切不命中。
4. 2H分配到块4；且不命中。
5. 0H分配到块1；覆盖4H内容；且不命中。
6. 6H分配到块5；切不命中。
7. 8H命中，内容在块0
8. 6H命中，内容在块5
9. 4H分配到块1；覆盖0H内容，且不命中。
10.8H命中，内容在块0.
个人认为这个LRU是在一个组内相关的替换算法，即如果一个组内的块都有内容，选择LRU的那个块作为替换块。
```

![](https://i.loli.net/2019/06/20/5d0b3a87047c068046.png)

大概很多人会倾向于选择D。原因是这里的访问数组包含两个操作：读+写。如果只考虑到读没考虑到写的问题，那么计算得到D是非常自然的，且非常自信自己得到的是正确答案。

如何分析，首先看数组共1000个int数据，就是4000B，需要占用的主存块数是4000B/16B = 250块。Cache大小是1024B，一块是16B，因此共有64块。

问题简化为250块主存块映射到64块Cache的过程。主存与Cache块的交换单位是块，也就是4个int数据。也就是第一个数据不命中，调入后剩下三个都命中。可以说25%吗？

错！看执行语句是什么。a[k] = a[k]+32

右边是读取数据，左边是写回数据。也就是对一个数据两次操作。且第一个数据读取时不命中，写Cache命中。块中剩下的三个数读写都命中，也就是一块中的4个数据的8次操作，只有一次不命中！所以不命中率是 1/8 = 12.5%.


![](https://i.loli.net/2019/06/20/5d0b3d79a34f352352.png)

（主存 （Cache）） 

（页表 （TLB））

![](https://i.loli.net/2019/06/20/5d0b3ed06da8780778.png)


首先，**小端存储**是指：数据的高位存在高地址，数据的低位存在低地址。

比如十六进制数0x123456，则我们知道12是最高位，34其次，56最低。那么存储的时候，如果用的是小端序，内存地址最小的那个用来存储56，地址增大一些存34，再高一些存12.

这里，其实我还要一个没弄明白的问题，分配的int数据，这个地址是高位还是低位？ 

当然按照题目的做法是，指代低位，继续增长。因此，一个int数据的4个字节，0xC008指代的是最小的地址。 

现在我们把这个假定为一个条件，不去细说（我还不知道怎么来的）。

接着，重点在于对齐，结构体中会根据第一个数据的大小进行对齐。 
问题来了，我们是按照最大数据进行对齐还是按照第一个数据进行对齐？

不同机器上的对齐策略不同，一般按照int的4个字节进行对齐。 
而这个结构体共7个字节，所以对齐后是8个字节。

那么这个留空的字节位置在哪？

就需要牵涉到变量起始地址的问题。

**规定：变量的起始地址必须能够被自身数据类型的大小整除。**

对于273，十六进制是0x111，因此第一个低位字节存储0x11，再高一点的字节存储0x01，后面两个字节为空的不管。好了，看存储char b，这个大小是1个字节，存完之后，如果紧接着就存short c，那么c的起始地址是个奇数，不能被2整除。 

因此在char b后留白一个字节。

所以,问题得解。

![](https://i.loli.net/2019/06/20/5d0b42762c40a81981.png)

### 虚拟存储器

虚存地址空间4GB，则虚地址长度为32位，主存地址空间256MB，则主存地址长度为28位。页面大小4KB，则页内地址长度为12位。虚拟地址03FF F180H中180H为页内地址，03FFFH为虚页号，查TLB(快表)发现，该页在主存中，其实页号为0153H，所以虚实地址变换后的结果为0153180H。


![](https://i.loli.net/2019/06/20/5d0b47662f8cb64016.png)

![](https://i.loli.net/2019/06/20/5d0b47887fa0c49008.png)

1. 页面大小为 4KB = 2^12 B，故页内地址12位。

虚拟地址空间大小为16MB=2^24B，故虚地址共24位，低12位为页内地址，高24-12位为虚页号

主存地址空间为1MB = 2^20B，故实地址为20位，低12位为页内地址，高24-12位为页框号

2. 主存与 Cache 之间交换的块的大小为32B = 2^5B，故 Cache 块内地址5位。

Cache 共8=2^3行，故 Cache 大小为 32*8=256B=2^8B，Cache 地址=3位 Cache 行号 + 5位行内地址。

主存物理地址区数 = 1MB/256B = 2^12 = 4096

故物理地址分三个字段：高23位为标记 tag，中间3位为 cache 行号，最低5位为行内地址。


![](https://i.loli.net/2019/06/20/5d0b4ddd1479079295.png)

![](https://i.loli.net/2019/06/20/5d0b4decc600061981.png)

## 指令系统

![](https://i.loli.net/2019/06/20/5d0b61625d72a81809.png)

cpu读取一条单字长指令，此指令占用2个字节，因此PC值自动增加2，仍然是指向下一条指令。

字长是16，但编址是按照字节（8位）编制的，所以此指令占用几个字节，PC就增加几，指令包括控制命令和操作数。


![](https://i.loli.net/2019/06/20/5d0b64a9214ec42396.png)

按字编址，PC + 1 则指令为2字节。

当前 PC 为 2003H，执行后为 2003 + 2 = 2005H，则跳转 05H。

![](https://i.loli.net/2019/06/20/5d0b66f82040092624.png)


![](https://i.loli.net/2019/06/21/5d0c676e17f4633296.png)

EA=(R)+A=1000H+2000H=3000H，操作数S=(3000H)=4000H


![](https://i.loli.net/2019/06/21/5d0c6f23782b759193.png)

采用32位定长指令字,其中操作码为8位,两个地址码一共占用32-8=24位,而Store指令的源操作数和目的操作数分别采用寄存器直接寻址和基址寻址,机器敏感词有 16 个通用寄存器,则寻址一个寄存器需要log216=4 位,源操作数中的寄存器直接寻址用掉4位, 而目的操作数采用基址寻址也要指定一个寄存器,同样用掉 4 位,则留给偏移址的位数为24-4-4=16 位,而偏移址用补码表示,16 位补码的表示范围为-32768~+32767







<hr />
