<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[IoC容器浅析及简单实现]]></title>
    <url>%2F%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3%2F2018%2F11%2F25%2FIoC%E5%AE%B9%E5%99%A8%E6%B5%85%E6%9E%90%E5%8F%8A%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0.html</url>
    <content type="text"><![CDATA[Spring IoC 容器是 Spring 框架中最核心的部分，也是初学者难以理解的部分，对于这种关键的设计，简单实现一次能最大限度地加深理解，了解其中思想，对以后的开发也大有裨益。 Spring IoC 容器浅析及简单实现Spring IoC 概述原生的 JavaEE 技术中各个模块之间的联系较强，即耦合度较高。 比如完成一个用户的创建事务，视图层会创建业务逻辑层的对象，再在内部调用对象的方法，各个模块的独立性很差，如果某一模块的代码发生改变，其他模块的改动也会很大。 而 Spring 框架的核心——IoC（控制反转）很好的解决了这一问题。控制反转，即某一接口具体实现类的选择控制权从调用类中移除，转交给第三方决定，即由 Spring 容器借由 Bean 配置来进行控制。 可能 IoC 不够开门见山，理解起来较为困难。因此， Martin Fowler 提出了 DI（Dependency Injection，依赖注入）的概念来替代 IoC，即让调用类对某一接口实现类的依赖关系由第三方（容器或写协作类）注入，以移除调用类对某一接口实现类的依赖。 比如说， 上述例子中，视图层使用业务逻辑层的接口变量，而不需要真正 new 出接口的实现，这样即使接口产生了新的实现或原有实现修改，视图层都能正常运行。 从注入方法上看，IoC 主要划分为三种类型：构造函数注入、属性注入和接口注入。在开发过程中，一般使用属性注入的方法。 IoC 不仅可以实现类之间的解耦，还能帮助完成类的初始化与装配工作，让开发者从这些底层实现类的实例化、依赖关系装配等工作中解脱出出来，专注于更有意义的业务逻辑开发工作。 Spring IoC 简单实现下面实现了一个IoC容器的核心部分，简单模拟了IoC容器的基本功能。 下面列举出核心类： Student.java 123456789101112131415161718192021222324252627282930313233/** * @ClassName Student * @Description 学生实体类 * @Author Yixiang Zhao * @Date 2018/9/22 9:19 * @Version 1.0 */public class Student &#123; private String name; private String gender; public void intro() &#123; System.out.println("My name is " + name + " and I'm " + gender + " ."); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125;&#125; StuService.java 12345678910111213141516171819/** * @ClassName StuService * @Description 学生Service * @Author Yixiang Zhao * @Date 2018/9/22 9:21 * @Version 1.0 */public class StuService &#123; private Student student; public Student getStudent() &#123; return student; &#125; public void setStudent(Student student) &#123; this.student = student; &#125;&#125; beans.xml 123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans&gt; &lt;bean id="Student" class="me.seriouszyx.pojo.Student"&gt; &lt;property name="name" value="ZYX"/&gt; &lt;property name="gender" value="man"/&gt; &lt;/bean&gt; &lt;bean id="StuService" class="me.seriouszyx.service.StuService"&gt; &lt;property ref="Student"/&gt; &lt;/bean&gt;&lt;/beans&gt; 下面是核心类 ClassPathXMLApplicationContext.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * @ClassName ClassPathXMLApplicationContext * @Description ApplicationContext的实现，核心类 * @Author Yixiang Zhao * @Date 2018/9/22 9:40 * @Version 1.0 */public class ClassPathXMLApplicationContext implements ApplicationContext &#123; private Map map = new HashMap(); public ClassPathXMLApplicationContext(String location) &#123; try &#123; Document document = getDocument(location); XMLParsing(document); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; // 加载资源文件，转换成Document类型 private Document getDocument(String location) throws JDOMException, IOException &#123; SAXBuilder saxBuilder = new SAXBuilder(); return saxBuilder.build(this.getClass().getClassLoader().getResource(location)); &#125; private void XMLParsing(Document document) throws Exception &#123; // 获取XML文件根元素beans Element beans = document.getRootElement(); // 获取beans下的bean集合 List beanList = beans.getChildren("bean"); // 遍历beans集合 for (Iterator iter = beanList.iterator(); iter.hasNext(); ) &#123; Element bean = (Element) iter.next(); // 获取bean的属性id和class，id为类的key值，class为类的路径 String id = bean.getAttributeValue("id"); String className = bean.getAttributeValue("class"); // 动态加载该bean代表的类 Object obj = Class.forName(className).newInstance(); // 获得该类的所有方法 Method[] methods = obj.getClass().getDeclaredMethods(); // 获取该节点的所有子节点，子节点存储类的初始化参数 List&lt;Element&gt; properties = bean.getChildren("property"); // 遍历，将初始化参数和类的方法对应，进行类的初始化 for (Element pro : properties) &#123; for (int i = 0; i &lt; methods.length; i++) &#123; String methodName = methods[i].getName(); if (methodName.startsWith("set")) &#123; String classProperty = methodName.substring(3, methodName.length()).toLowerCase(); if (pro.getAttribute("name") != null) &#123; if (classProperty.equals(pro.getAttribute("name").getValue())) &#123; methods[i].invoke(obj, pro.getAttribute("value").getValue()); &#125; &#125; else &#123; methods[i].invoke(obj, map.get(pro.getAttribute("ref").getValue())); &#125; &#125; &#125; &#125; // 将初始化完成的对象添加到HashMap中 map.put(id, obj); &#125; &#125; public Object getBean(String name) &#123; return map.get(name); &#125;&#125; 最后进行测试 1234567public class MyIoCTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXMLApplicationContext("beans.xml"); StuService stuService = (StuService) context.getBean("StuService"); stuService.getStudent().intro(); &#125;&#125; 测试成功！ 123My name is ZYX and I&apos;m man .Process finished with exit code 0 源码代码在我的 GitHub开源，欢迎一起交流讨论。 总结熟悉一个框架最好的方式，就是亲手实现它。这样不仅会深刻地认识到框架的工作原理，以后的使用也会更加得心应手。 此外，在实现的过程中，又会收获很多东西，就像实现 IoC 容器一样，不仅了解解析 XML 文件的 JDOM 工具，还加深了对 Java 反射的理解。在实际开发中，几乎没有任何地方需要用到反射这一技术，但在框架实现过程中，不懂反射则寸步难行。 更多的 Spring 学习心得请戳Spring 框架学习]]></content>
      <categories>
        <category>技术相关</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Funcategorized%2F2018%2F11%2F23%2Fhello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
