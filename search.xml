<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[就决定是你了 | 为你的终端安装 Pokemon 皮肤]]></title>
    <url>%2F%E6%8A%98%E8%85%BE%2F2018%2F11%2F27%2F%E5%B0%B1%E5%86%B3%E5%AE%9A%E6%98%AF%E4%BD%A0%E4%BA%86-%E4%B8%BA%E4%BD%A0%E7%9A%84%E7%BB%88%E7%AB%AF%E5%AE%89%E8%A3%85-Pokemon-%E7%9A%AE%E8%82%A4.html</url>
    <content type="text"><![CDATA[正值精灵宝可梦大热时期，在逛 GitHub 时发现了一个特别强的东西 —— Pokemon-Terminal，经过一顿折腾后，终于把终端打造成了这个样子 👇 Pokemon-Terminal正值精灵宝可梦大热时期，在逛 GitHub 时发现了一个特别强的东西 —— Pokemon-Terminal 这是一款美化终端的神器，将口袋妖怪与终端完美结合，先上几张图让大家感受一下： 它拥有 719 款 Pokemon 皮肤，可以根据编号或口袋妖怪名字（例如 pikachu）改变，支持 iTerm2、ConEmu、Terminology、Tilix 等终端，同时支持 Windows、MacOS、GNOME、Openbox 和 i3wm。 如果你也是个口袋迷，那么快来给你的终端安上这款皮肤吧！ 安装本项目的 README 上有各种安装方法，这里以 macOS 为例。 首先确保你的电脑已经安装 3.6 及以上版本的 python（最好是 3.6），下面是下载地址 For Mac For Windows For Ubuntu For Arch Linux 确保有以下终端模拟器中的一种（我用的是 iTerm2） iTerm2 ConEmu or derivative (such as Cmder) Terminology Tilix 可以使用以下几种方式安装 Arch Linux User Repository package (System-wide) pip (System-wide) pip (Per-User) npm (Per-User) Distutils (System-wide) 这里我使用 npm 安装（确保有 node.js），因为比较简单。 在 iTerm 2 中输入以下命令 1npm install --global pokemon-terminal 好了，这就安装成功了，是不是非常简单！ 1$ pokemon pikachu 皮卡丘，就决定是你了! 深度使用每次启动都想自动随机更换皮肤的话，可以像这样设置： 还有原项目给出的使用方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950usage: pokemon [-h] [-n NAME] [-r [&#123;kanto,johto,hoenn,sinnoh,unova,kalos&#125; [&#123;kanto,johto,hoenn,sinnoh,unova,kalos&#125; ...]]] [-l [0.xx]] [-d [0.xx]] [-t [&#123;normal,fire,fighting,water,flying,grass,poison,electric,ground,psychic,rock,ice,bug,dragon,ghost,dark,steel,fairy&#125; [&#123;normal,fire,fighting,water,flying,grass,poison,electric,ground,psychic,rock,ice,bug,dragon,ghost,dark,steel,fairy&#125; ...]]] [-ne] [-e] [-ss [X]] [-w] [-v] [-dr] [-c] [id]Set a pokemon to the current terminal background or wallpaperpositional arguments: id Specify the wanted pokemon ID or the exact (case insensitive) nameoptional arguments: -h, --help show this help message and exit -c, --clear Clears the current pokemon from terminal background and quits.Filters: Arguments used to filter the list of pokemons with various conditions that then will be picked -n NAME, --name NAME Filter by pokemon which name contains NAME -r [&#123;kanto,johto,hoenn,sinnoh,unova,kalos&#125; [&#123;kanto,johto,hoenn,sinnoh,unova,kalos&#125; ...]], --region [&#123;kanto,johto,hoenn,sinnoh,unova,kalos&#125; [&#123;kanto,johto,hoenn,sinnoh,unova,kalos&#125; ...]] Filter the pokemons by region -l [0.xx], --light [0.xx] Filter out the pokemons darker (lightness threshold lower) then 0.xx (default is 0.7) -d [0.xx], --dark [0.xx] Filter out the pokemons lighter (lightness threshold higher) then 0.xx (default is 0.42) -t [&#123;normal,fire,fighting,water,flying,grass,poison,electric,ground,psychic,rock,ice,bug,dragon,ghost,dark,steel,fairy&#125; [&#123;normal,fire,fighting,water,flying,grass,poison,electric,ground,psychic,rock,ice,bug,dragon,ghost,dark,steel,fairy&#125; ...]], --type [&#123;normal,fire,fighting,water,flying,grass,poison,electric,ground,psychic,rock,ice,bug,dragon,ghost,dark,steel,fairy&#125; [&#123;normal,fire,fighting,water,flying,grass,poison,electric,ground,psychic,rock,ice,bug,dragon,ghost,dark,steel,fairy&#125; ...]] Filter the pokemons by type. -ne, --no-extras Excludes extra pokemons (from the extras folder) -e, --extras Excludes all non-extra pokemonsMisc: -ss [X], --slideshow [X] Instead of simply choosing a random pokemon from the filtered list, starts a slideshow (with X minutes of delay between pokemon) in the background with the pokemon that matched the filters -w, --wallpaper Changes the desktop wallpaper instead of the terminal background -v, --verbose Enables verbose output -dr, --dry-run Implies -v and doesn&apos;t actually changes either wallpaper or background after the pokemon has been chosenNot setting any filters will get a completely random pokemon 举几个例子，可以根据口袋妖怪的名字改变皮肤 同一款皮肤（部分）还可以改变不同的形态 还可以自定义图片之类的，自己摸索吧。 终端美化作者建议更改终端默认的透明度的模糊程度，以达到更好的效果，可以像这样设置： 设置之后就会变成这个样子： iTerm 2 的默认功能还是不够强大，可以配置 oh-my-zsh，安装字体库、插件等，如果有需要可以参考这篇文章 iTerm2 + Oh My Zsh 打造舒适终端体验。 最后，安装配置了 iTerm 2 + oh-my-zsh + Pokemon-Terminal，你就拥有了像下面一样的终端。 Have fun !]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>折腾</tag>
        <tag>Linux</tag>
        <tag>终端</tag>
        <tag>美化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IoC容器浅析及简单实现]]></title>
    <url>%2F%E6%8A%80%E6%9C%AF%E7%9B%B8%E5%85%B3%2F2018%2F11%2F25%2FIoC%E5%AE%B9%E5%99%A8%E6%B5%85%E6%9E%90%E5%8F%8A%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0.html</url>
    <content type="text"><![CDATA[Spring IoC 容器是 Spring 框架中最核心的部分，也是初学者难以理解的部分，对于这种关键的设计，简单实现一次能最大限度地加深理解，了解其中思想，对以后的开发也大有裨益。 Spring IoC 容器浅析及简单实现Spring IoC 概述原生的 JavaEE 技术中各个模块之间的联系较强，即耦合度较高。 比如完成一个用户的创建事务，视图层会创建业务逻辑层的对象，再在内部调用对象的方法，各个模块的独立性很差，如果某一模块的代码发生改变，其他模块的改动也会很大。 而 Spring 框架的核心——IoC（控制反转）很好的解决了这一问题。控制反转，即某一接口具体实现类的选择控制权从调用类中移除，转交给第三方决定，即由 Spring 容器借由 Bean 配置来进行控制。 可能 IoC 不够开门见山，理解起来较为困难。因此， Martin Fowler 提出了 DI（Dependency Injection，依赖注入）的概念来替代 IoC，即让调用类对某一接口实现类的依赖关系由第三方（容器或写协作类）注入，以移除调用类对某一接口实现类的依赖。 比如说， 上述例子中，视图层使用业务逻辑层的接口变量，而不需要真正 new 出接口的实现，这样即使接口产生了新的实现或原有实现修改，视图层都能正常运行。 从注入方法上看，IoC 主要划分为三种类型：构造函数注入、属性注入和接口注入。在开发过程中，一般使用属性注入的方法。 IoC 不仅可以实现类之间的解耦，还能帮助完成类的初始化与装配工作，让开发者从这些底层实现类的实例化、依赖关系装配等工作中解脱出出来，专注于更有意义的业务逻辑开发工作。 Spring IoC 简单实现下面实现了一个IoC容器的核心部分，简单模拟了IoC容器的基本功能。 下面列举出核心类： Student.java 123456789101112131415161718192021222324252627282930313233/** * @ClassName Student * @Description 学生实体类 * @Author Yixiang Zhao * @Date 2018/9/22 9:19 * @Version 1.0 */public class Student &#123; private String name; private String gender; public void intro() &#123; System.out.println("My name is " + name + " and I'm " + gender + " ."); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125;&#125; StuService.java 12345678910111213141516171819/** * @ClassName StuService * @Description 学生Service * @Author Yixiang Zhao * @Date 2018/9/22 9:21 * @Version 1.0 */public class StuService &#123; private Student student; public Student getStudent() &#123; return student; &#125; public void setStudent(Student student) &#123; this.student = student; &#125;&#125; beans.xml 123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans&gt; &lt;bean id="Student" class="me.seriouszyx.pojo.Student"&gt; &lt;property name="name" value="ZYX"/&gt; &lt;property name="gender" value="man"/&gt; &lt;/bean&gt; &lt;bean id="StuService" class="me.seriouszyx.service.StuService"&gt; &lt;property ref="Student"/&gt; &lt;/bean&gt;&lt;/beans&gt; 下面是核心类 ClassPathXMLApplicationContext.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * @ClassName ClassPathXMLApplicationContext * @Description ApplicationContext的实现，核心类 * @Author Yixiang Zhao * @Date 2018/9/22 9:40 * @Version 1.0 */public class ClassPathXMLApplicationContext implements ApplicationContext &#123; private Map map = new HashMap(); public ClassPathXMLApplicationContext(String location) &#123; try &#123; Document document = getDocument(location); XMLParsing(document); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; // 加载资源文件，转换成Document类型 private Document getDocument(String location) throws JDOMException, IOException &#123; SAXBuilder saxBuilder = new SAXBuilder(); return saxBuilder.build(this.getClass().getClassLoader().getResource(location)); &#125; private void XMLParsing(Document document) throws Exception &#123; // 获取XML文件根元素beans Element beans = document.getRootElement(); // 获取beans下的bean集合 List beanList = beans.getChildren("bean"); // 遍历beans集合 for (Iterator iter = beanList.iterator(); iter.hasNext(); ) &#123; Element bean = (Element) iter.next(); // 获取bean的属性id和class，id为类的key值，class为类的路径 String id = bean.getAttributeValue("id"); String className = bean.getAttributeValue("class"); // 动态加载该bean代表的类 Object obj = Class.forName(className).newInstance(); // 获得该类的所有方法 Method[] methods = obj.getClass().getDeclaredMethods(); // 获取该节点的所有子节点，子节点存储类的初始化参数 List&lt;Element&gt; properties = bean.getChildren("property"); // 遍历，将初始化参数和类的方法对应，进行类的初始化 for (Element pro : properties) &#123; for (int i = 0; i &lt; methods.length; i++) &#123; String methodName = methods[i].getName(); if (methodName.startsWith("set")) &#123; String classProperty = methodName.substring(3, methodName.length()).toLowerCase(); if (pro.getAttribute("name") != null) &#123; if (classProperty.equals(pro.getAttribute("name").getValue())) &#123; methods[i].invoke(obj, pro.getAttribute("value").getValue()); &#125; &#125; else &#123; methods[i].invoke(obj, map.get(pro.getAttribute("ref").getValue())); &#125; &#125; &#125; &#125; // 将初始化完成的对象添加到HashMap中 map.put(id, obj); &#125; &#125; public Object getBean(String name) &#123; return map.get(name); &#125;&#125; 最后进行测试 1234567public class MyIoCTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXMLApplicationContext("beans.xml"); StuService stuService = (StuService) context.getBean("StuService"); stuService.getStudent().intro(); &#125;&#125; 测试成功！ 123My name is ZYX and I&apos;m man .Process finished with exit code 0 源码代码在我的 GitHub开源，欢迎一起交流讨论。 总结熟悉一个框架最好的方式，就是亲手实现它。这样不仅会深刻地认识到框架的工作原理，以后的使用也会更加得心应手。 此外，在实现的过程中，又会收获很多东西，就像实现 IoC 容器一样，不仅了解解析 XML 文件的 JDOM 工具，还加深了对 Java 反射的理解。在实际开发中，几乎没有任何地方需要用到反射这一技术，但在框架实现过程中，不懂反射则寸步难行。 更多的 Spring 学习心得请戳Spring 框架学习]]></content>
      <categories>
        <category>技术相关</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
